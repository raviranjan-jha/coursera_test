<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
	<title>Links</title>
</head>
<body>
<h1 id="top"> Links to Sections of the same page.</h1>
<section>
	<ul>
		<li><a href="#section1">#section1</a></li>
		<li><a href="#section2">#section2</a></li>
		<li><a href="#section3">section3</a></li>
		<li><a href="#section4">#section4</a></li>
		<li><a href="#section5">#section5</a></li>
		<li><p>You can also connect to my facebook page<a href="https://www.facebook.com/profile.php?id=100002009362587" , target="_blank"> Facebook_Ravi</a></p></li>
	</ul>
</section>
<section id="section1">
	<h3>(#section1) Section1</h3>
	<p>
		The first thing you should do when you install Git is to set your user name and
email address. This is important because every Git commit uses this information,
and it’s immutably baked into the commits you start creating:
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
Again, you need to do this only once if you pass the --global option, because
then Git will always use that information for anything you do on that system.
If you want to override this with a dierent name or email address for specific
projects, you can run the command without the --global option when
you’re in that project.
Many of the GUI tools will help you do this when you first run them.
	</p>
</section>
<section id="section2">
<h3>(#section2) Section 2</h3>
<p>
	You should have a basic understanding of what Git is and how it’s dierent from
the centralized version control system you may have previously been using. You
should also now have a working version of Git on your system that’s set up with
your personal identity. It’s now time to learn some Git basics.
</p>
</section>
<section id="section3">
	<h3>(#section3) Section 3</h3>
	<p>
		If you can read only one chapter to get going with Git, this is it. This chapter
covers every basic command you need to do the vast majority of the things
you’ll eventually spend your time doing with Git. By the end of the chapter, you
should be able to configure and initialize a repository, begin and stop tracking
files, and stage and commit changes. We’ll also show you how to set up Git to
ignore certain files and file patterns, how to undo mistakes quickly and easily,
how to browse the history of your project and view changes between commits,
and how to push and pull from remote repositories.
The first line tells Git to ignore any files ending in “.o” or “.a” – object and
archive files that may be the product of building your code. The second line
tells Git to ignore all files whose names end with a tilde (~), which is used by
many text editors such as Emacs to mark temporary files. You may also include
a log, tmp, or pid directory; automatically generated documentation; and so
on. Setting up a .gitignore file before you get going is generally a good idea
so you don’t accidentally commit files that you really don’t want in your Git
repository.
The rules for the patterns you can put in the .gitignore file are as follows:
• Blank lines or lines starting with # are ignored.
• Standard glob patterns work.
• You can start patterns with a forward slash (/) to avoid recursivity.
• You can end patterns with a forward slash (/) to specify a directory.
• You can negate a pattern by starting it with an exclamation point (!).
Glob patterns are like simplified regular expressions that shells use. An asterisk
(*) matches zero or more characters; [abc] matches any character inside
the brackets (in this case a, b, or c); a question mark (?) matches a single character;
and brackets enclosing characters separated by a hyphen ([0-9]) matches
any character between them (in this case 0 through 9). You can also use two
asterisks to match nested directories; a/**/z would match a/z, a/b/z,
a/b/c/z, and so on.
Here is another example .gitignore file:
	</p>
</section>
<section id="section4">
	<h3>(#section4) Section 4</h3>
	<p>
		If you can read only one chapter to get going with Git, this is it. This chapter covers every basic command you need to do the vast majority of the things you’ll eventually spend your time doing with Git. By the end of the chapter, you should be able to configure and initialize a repository, begin and stop tracking files, and stage and commit changes. We’ll also show you how to set up Git to ignore certain files and file patterns, how to undo mistakes quickly and easily, how to browse the history of your project and view changes between commits, and how to push and pull from remote repositories. The first line tells Git to ignore any files ending in “.o” or “.a” – object and archive files that may be the product of building your code. The second line tells Git to ignore all files whose names end with a tilde (~), which is used by many text editors such as Emacs to mark temporary files. You may also include a log, tmp, or pid directory; automatically generated documentation; and so on. Setting up a .gitignore file before you get going is generally a good idea so you don’t accidentally commit files that you really don’t want in your Git repository. The rules for the patterns you can put in the .gitignore file are as follows: • Blank lines or lines starting with # are ignored. • Standard glob patterns work. • You can start patterns with a forward slash (/) to avoid recursivity. • You can end patterns with a forward slash (/) to specify a directory. • You can negate a pattern by starting it with an exclamation point (!). Glob patterns are like simplified regular expressions that shells use. An asterisk (*) matches zero or more characters; [abc] matches any character inside the brackets (in this case a, b, or c); a question mark (?) matches a single character; and brackets enclosing characters separated by a hyphen ([0-9]) matches any character between them (in this case 0 through 9). You can also use two asterisks to match nested directories; a/**/z would match a/z, a/b/z, a/b/c/z, and so on. Here is another example .gitignore file
		If you want to get a copy of an existing Git repository – for example, a project
you’d like to contribute to – the command you need is git clone. If you’re familiar
with other VCS systems such as Subversion, you’ll notice that the command
is “clone” and not “checkout”. This is an important distinction – instead
of getting just a working copy, Git receives a full copy of nearly all data that the
server has. Every version of every file for the history of the project is pulled
down by default when you run git clone. In fact, if your server disk gets corrupted,
you can oen use nearly any of the clones on any client to set the server
back to the state it was in when it was cloned (you may lose some server-side
hooks and such, but all the versioned data would be there – see “Getting Git
on a Server” for more details).
	</p>
</section>
<section >
	<h3><a name="section5"> (#section5) Section 5</a></h3>
	<p>
		That creates a directory named “libgit2”, initializes a .git directory inside it,
pulls down all the data for that repository, and checks out a working copy of the
latest version. If you go into the new libgit2 directory, you’ll see the project
files in there, ready to be worked on or used. If you want to clone the repository
into a directory named something other than “libgit2”, you can specify that as
the next command-line option:
You have a bona fide Git repository and a checkout or working copy of the files
for that project. You need to make some changes and commit snapshots of
those changes into your repository each time the project reaches a state you
want to record.
Remember that each file in your working directory can be in one of two
states: tracked or untracked. Tracked files are files that were in the last snapshot;
they can be unmodified, modified, or staged. Untracked files are everything
else – any files in your working directory that were not in your last snapshot
and are not in your staging area. When you first clone a repository, all of
your files will be tracked and unmodified because Git just checked them out
and you haven’t edited anything.
As you edit files, Git sees them as modified, because you’ve changed them
since your last commit. You stage these modified files and then commit all your
staged changes, and the cycle repeats.
	</p>
</section>
<div><p> Back to the Top <a href="#top">Back to the top</a></p></div>
</body>
</html>